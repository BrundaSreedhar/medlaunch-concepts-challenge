# Malware/Virus Scanning Integration Guide

## Overview

This document describes how to integrate malware and virus scanning into the file upload system for production use. The current implementation includes hooks and architecture that make it easy to add scanning capabilities.

## Architecture Considerations

The file upload system is designed with a modular architecture that supports scanning integration:

1. **File Storage Abstraction**: The `FileStorageService` interface allows for easy integration of scanning before file storage
2. **Validation Layer**: The `FileValidator` class can be extended to include malware scanning
3. **Upload Flow**: Files are processed in memory before being saved, making them available for scanning

## Recommended Integration Approaches

### Option 1: Pre-Storage Scanning (Recommended)

Scan files **before** they are saved to storage. This prevents malicious files from entering the system.

#### Implementation Steps:

1. **Add Scanning Service Interface**:
   ```typescript
   // src/service/ScanningService.ts
   export interface IScanningService {
     scanFile(file: Express.Multer.File): Promise<ScanResult>;
   }
   
   export interface ScanResult {
     clean: boolean;
     threats?: string[];
     error?: string;
   }
   ```

2. **Integrate into Upload Route**:
   ```typescript
   // In App.ts upload route, before saving file:
   const scanResult = await this.scanningService.scanFile(req.file);
   if (!scanResult.clean) {
     return res.status(400).json({ 
       error: 'File failed security scan',
       threats: scanResult.threats 
     });
   }
   ```

### Option 2: Post-Storage Scanning with Quarantine

Save files to a quarantine area first, scan them, then move to final storage if clean.

#### Implementation Steps:

1. Create a quarantine storage area
2. Save files to quarantine initially
3. Scan files asynchronously
4. Move clean files to final storage
5. Delete/quarantine infected files

### Option 3: Cloud-Based Scanning

Use cloud services that scan files automatically (e.g., AWS S3 with VirusTotal integration, Azure Blob with Defender).

## Recommended Scanning Solutions

### 1. ClamAV (Open Source)

**Pros**: Free, open-source, widely used, good detection rates
**Cons**: Requires server setup, needs regular signature updates

**Integration Example**:
```typescript
import { exec } from 'child_process';
import { promisify } from 'util';
const execAsync = promisify(exec);

export class ClamAVScanner implements IScanningService {
  async scanFile(file: Express.Multer.File): Promise<ScanResult> {
    // Write file to temp location
    const tempPath = `/tmp/${file.originalname}`;
    await fs.promises.writeFile(tempPath, file.buffer);
    
    try {
      // Run ClamAV scan
      const { stdout } = await execAsync(`clamdscan ${tempPath}`);
      
      // Clean up temp file
      await fs.promises.unlink(tempPath);
      
      // Parse output
      if (stdout.includes('FOUND')) {
        return { clean: false, threats: [stdout] };
      }
      return { clean: true };
    } catch (error) {
      await fs.promises.unlink(tempPath).catch(() => {});
      return { clean: false, error: 'Scan failed' };
    }
  }
}
```

### 2. VirusTotal API

**Pros**: Cloud-based, no server setup, excellent detection (multiple engines)
**Cons**: Rate limits on free tier, requires API key, files sent to third party

**Integration Example**:
```typescript
import axios from 'axios';

export class VirusTotalScanner implements IScanningService {
  private apiKey: string;
  
  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
  
  async scanFile(file: Express.Multer.File): Promise<ScanResult> {
    // Upload file hash first (faster)
    const fileHash = crypto.createHash('sha256').update(file.buffer).digest('hex');
    
    try {
      // Check hash first
      const hashCheck = await axios.get(
        `https://www.virustotal.com/vtapi/v2/file/report`,
        { params: { apikey: this.apiKey, resource: fileHash } }
      );
      
      if (hashCheck.data.response_code === 1) {
        const positives = hashCheck.data.positives || 0;
        return { 
          clean: positives === 0,
          threats: positives > 0 ? ['Known malicious file'] : undefined
        };
      }
      
      // If hash not found, upload file (for files < 32MB)
      if (file.size < 32 * 1024 * 1024) {
        const formData = new FormData();
        formData.append('file', file.buffer, file.originalname);
        
        const uploadResponse = await axios.post(
          'https://www.virustotal.com/vtapi/v2/file/scan',
          formData,
          { 
            headers: { 'x-apikey': this.apiKey },
            params: { apikey: this.apiKey }
          }
        );
        
        // Poll for results (or use webhook)
        return await this.pollScanResults(uploadResponse.data.scan_id);
      }
      
      return { clean: false, error: 'File too large for VirusTotal' };
    } catch (error) {
      return { clean: false, error: 'Scan failed' };
    }
  }
}
```

### 3. AWS Macie / GuardDuty

**Pros**: Native AWS integration, automated, enterprise-grade
**Cons**: AWS-only, additional cost, requires AWS infrastructure

### 4. Cloudflare Workers with Scanning

**Pros**: Edge-based, fast, scalable
**Cons**: Requires Cloudflare infrastructure

## Production Implementation Checklist

- [ ] **Choose scanning solution** based on requirements (cost, performance, detection rate)
- [ ] **Implement scanning service** following the `IScanningService` interface
- [ ] **Add scanning to upload flow** before file storage
- [ ] **Handle scanning failures gracefully** (fail open vs fail closed policy)
- [ ] **Log all scan results** for audit and monitoring
- [ ] **Set up monitoring/alerts** for detected threats
- [ ] **Configure rate limiting** if using API-based solutions
- [ ] **Update file validation** to include scan results
- [ ] **Add retry logic** for transient scanning failures
- [ ] **Implement quarantine workflow** for suspicious files
- [ ] **Set up signature updates** for ClamAV or similar solutions

## Security Best Practices

1. **Never trust file extensions**: Always validate file content, not just extensions
2. **Scan before storage**: Prevent malicious files from entering the system
3. **Use multiple detection methods**: Combine signature-based and behavior-based scanning
4. **Regular updates**: Keep scanning signatures/engines up to date
5. **Isolate scanning**: Run scanning in isolated environments when possible
6. **Monitor and alert**: Set up alerts for detected threats
7. **Audit logs**: Log all scanning activities for compliance
8. **Rate limiting**: Prevent abuse of scanning services
9. **Fail-secure**: Default to blocking files if scanning is unavailable (configurable)

## Example Integration in Current Codebase

To integrate scanning into the current implementation:

1. Add scanning service to `App.ts` constructor:
   ```typescript
   private scanningService: IScanningService;
   
   constructor(dbPath: string) {
     // ... existing code ...
     this.scanningService = new ClamAVScanner(); // or VirusTotalScanner, etc.
   }
   ```

2. Update upload route to scan before saving:
   ```typescript
   // After file validation, before saving:
   const scanResult = await this.scanningService.scanFile(req.file);
   if (!scanResult.clean) {
     return res.status(400).json({ 
       error: 'File failed security scan',
       threats: scanResult.threats 
     });
   }
   ```

3. Add environment variables for configuration:
   ```
   SCANNING_ENABLED=true
   SCANNING_SERVICE=clamav
   VIRUSTOTAL_API_KEY=your_key_here
   ```

## Performance Considerations

- **Synchronous scanning**: Blocks upload until scan completes (more secure, slower)
- **Asynchronous scanning**: Upload completes, scan in background (faster, less secure)
- **Hybrid approach**: Quick hash check first, full scan in background
- **Caching**: Cache scan results for identical files (by hash)

## Cost Considerations

- **ClamAV**: Free (server costs only)
- **VirusTotal**: Free tier limited, paid plans available
- **AWS Macie**: Pay-per-use pricing
- **Commercial solutions**: Varies by vendor

## Conclusion

The current architecture supports easy integration of malware scanning. Choose a solution based on your security requirements, budget, and infrastructure. For most production environments, a combination of ClamAV (for on-premise) or VirusTotal (for cloud) provides a good balance of security and cost.

